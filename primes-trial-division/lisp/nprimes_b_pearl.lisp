(defun divp (n plist)
  (mapc #'(lambda (p)
              (cond ((zerop (mod n p)) (return-from divp T)))) plist)
  (return-from divp nil))

(defun primes (n)
  (setq count 3)
  (setq primes (list 2))
  (tagbody NEXT (cond ((< (length primes) n)
                       (cond ((divp count primes) nil)
                             (T (nconc primes (list count)))))
                      (T (return-from primes primes)))
           (setq count (+ count 1))
           (go NEXT)))
